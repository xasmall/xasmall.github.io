{"meta":{"title":"XASMALL WORKSPACE","subtitle":"记录生活琐事","description":"","author":"xasmall","url":"http://119.29.194.249","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-11-14T02:32:59.766Z","updated":"2022-11-14T02:32:59.766Z","comments":false,"path":"/404.html","permalink":"http://119.29.194.249/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-11-14T02:32:59.820Z","updated":"2022-11-14T02:32:59.820Z","comments":false,"path":"books/index.html","permalink":"http://119.29.194.249/books/index.html","excerpt":"","text":""},{"title":"xasmall自我介绍","date":"2022-11-14T02:32:59.820Z","updated":"2022-11-14T02:32:59.820Z","comments":false,"path":"about/index.html","permalink":"http://119.29.194.249/about/index.html","excerpt":"","text":"记录个人遇到的一些问题 如有需要联系，请发邮件到xasmall@163.com"},{"title":"分类","date":"2022-11-14T02:32:59.821Z","updated":"2022-11-14T02:32:59.821Z","comments":false,"path":"categories/index.html","permalink":"http://119.29.194.249/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-11-14T02:32:59.823Z","updated":"2022-11-14T02:32:59.823Z","comments":false,"path":"tags/index.html","permalink":"http://119.29.194.249/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-11-14T02:32:59.822Z","updated":"2022-11-14T02:32:59.822Z","comments":false,"path":"repository/index.html","permalink":"http://119.29.194.249/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-14T02:32:59.821Z","updated":"2022-11-14T02:32:59.821Z","comments":false,"path":"links/index.html","permalink":"http://119.29.194.249/links/index.html","excerpt":"","text":""}],"posts":[{"title":"clash配置代理规则","slug":"clash配置代理规则","date":"2022-11-14T02:59:04.000Z","updated":"2022-11-14T03:05:57.980Z","comments":true,"path":"2022/11/14/clash配置代理规则/","link":"","permalink":"http://119.29.194.249/2022/11/14/clash%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E8%A7%84%E5%88%99/","excerpt":"","text":"clash代理配置问题 由于经常使用github，但是由于某些原因，不使用一些工具就经常断断续续，使用了工具又会出现git push不上去 所以设置git走代理 12git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy http://127.0.0.1:7890 7890就是代理端口啦 通过设置git代理，显然使用git的速度变得好了，现在又出现了一个问题 bing搜索自从更新后，使用代理搜索就会出现重定向次数过多的问题 我们需要设置clash代理规则，使得它不走代理 123456parsers: # array - url: https://sub-2.suki.best/sub?target=clash&amp;new_name=true&amp;url=https%3A%2F%2Fsockboom.me%2Flink%2FpPeKHmAVsGHoImBD&amp;filename=Sockboom&amp;udp=true&amp;config=https%3A%2F%2Fconfig.sub.suki.best%2Fsubconfig.ini yaml: prepend-rules: - DOMAIN-SUFFIX,cn.bing.com,DIRECT - DOMAIN-SUFFIX,www.bing.com,DIRECT 上图中url是你使用的配置的url DIRECT表示不走代理，这样设置好，你就可以好好使用啦","categories":[{"name":"代理","slug":"代理","permalink":"http://119.29.194.249/categories/%E4%BB%A3%E7%90%86/"}],"tags":[{"name":"clash","slug":"clash","permalink":"http://119.29.194.249/tags/clash/"}]},{"title":"redis-链表","slug":"redis-链表","date":"2022-06-11T02:23:07.000Z","updated":"2022-11-14T02:32:59.818Z","comments":true,"path":"2022/06/11/redis-链表/","link":"","permalink":"http://119.29.194.249/2022/06/11/redis-%E9%93%BE%E8%A1%A8/","excerpt":"","text":"redis-链表 由于redis使用的C语言并没有内置这种数据结构，所以redis构建了自己的链表实现 链表在redis中的应用十分广泛，列表键的底层实现之一就是链表，当一个列表键包含了数量很多的元素又或者列表中的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现 链表节点实现：本质上是一个双端链表 12345typedef struct listNode&#123; struct listNode *prev; struct listNode *next; void *value;&#125;listNode; 链表的结构体： 123456789101112typedef struct list&#123; listNode *head; listNode *tail; // 链表所包含的节点数量 unsigned long len; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void *(free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr,void *key);&#125; redis的链表实现特性： 1.双端 2.无环: 表头节点的prev指针和表尾节点的tail指针都指向null,对链表的访问以null为终点 3.多态：void*保存节点的值，可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同的值","categories":[{"name":"Redis","slug":"Redis","permalink":"http://119.29.194.249/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://119.29.194.249/tags/redis/"}]},{"title":"redis-简单动态字符串","slug":"redis-简单动态字符串","date":"2022-06-11T02:06:05.000Z","updated":"2022-11-14T02:32:59.818Z","comments":true,"path":"2022/06/11/redis-简单动态字符串/","link":"","permalink":"http://119.29.194.249/2022/06/11/redis-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"redis-简单动态字符串 SDS: 123456789struct sdshdr&#123; int len; // SDS所保存字符串的长度 int free; //记录buf数组中未使用字节的数量 char buf[]; //字节数组，用于保存字符串 // SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节(&#x27;\\0&#x27;)不计算再SDS的len属性里面，并且为空字符分类额外的1字节空间，以及添加空字符到字符串末尾等操作都是由SDS函数自动完成的&#125; SDS遵循空字符串结尾这一惯例的好处，就是SDS可以重用一部分C字符串函数里面的函数 SDS与C字符串的区别 1.常数复杂度获取字符串的长度 SDS保存了len属性，获取字符串长度的时间复杂度为O(1) // 设置和更新SDS长度的工作是由SDS的API在执行时自动完成的，使用SDS无需进行任何修改长度的工作 2.杜绝缓冲区溢出 C字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出，比如使用strcat,strcpy等函数 当SDS的API需要对SDS进行修改时，API会检查SDS的空间是否满足修改所需的要求，如果不满足，API会自动将SDS的空间扩展到修改所需的大小，然后才执行实际的修改操作 比如：SDS中的sdcat函数 3.减少修改字符串时带来的内存重分配次数 SDS通过使用未使用空间解除了字符串长度和底层数组长度之间的关联 所以SDS中buf数组的长度不一定是字符数量+1 空间预分配：当需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必需要的空间，还会为SDS分配额外的未使用空间 如果修改之后，SDS的长度小于1MB,那么程序分配和len属性同样大小的未使用空间 如果SDS长度大于等于1MB,那么程序会分配1MB的未使用空间 惰性空间释放：当SDS需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性来讲这些数量记录下来，等待将来使用 通过惰性空间释放，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能由的增长操作提供了优化， SDS也提供了API，让我们在有需要的时候，真正释放SDS的未使用空间 4.二进制安全 C字符串中的字符必须符合某种编码，并且处理字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符串被误认为是字符串结尾，这些限制使得C字符串只能保存文本数量，不能保存图片、音频、压缩文件这样的二进制数据 SDS使用len属性的值而不是空字符来判断字符串是否结束 5.兼容C字符函数 SDS总会在buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分string.h库定义的函数","categories":[{"name":"Redis","slug":"Redis","permalink":"http://119.29.194.249/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://119.29.194.249/tags/redis/"}]},{"title":"go语言学习-赋值","slug":"go语言学习-赋值","date":"2022-06-08T16:50:16.000Z","updated":"2022-11-14T02:32:59.817Z","comments":true,"path":"2022/06/09/go语言学习-赋值/","link":"","permalink":"http://119.29.194.249/2022/06/09/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E8%B5%8B%E5%80%BC/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport &quot;fmt&quot;// go语言的赋值操作type Books struct &#123; title string author string subject string book_id int&#125;func test1() &#123; // 普通赋值方法 var ( x int y *bool //声明一个bool类型的指针 ) x = 1 var t bool = false // 指针在进行操作之前必须赋值，这个地址应该是一个变量的地址 y = &amp;t *y = true var b Books b.author = &quot;张三&quot; b.book_id = 1 b.subject = &quot;普通图书&quot; b.title = &quot;go语言圣经&quot; fmt.Println(x, *y, b)&#125;// 求最大公约数func gcd(x, y int) int &#123; fmt.Println(x, y) for y != 0 &#123; x, y = y, x%y &#125; return x&#125;func test2() &#123; //元组赋值方法,允许同时更新多个变量的值，在赋值之前，赋值语句右边的所有表达式将会被先进行求值，然后再统一更新左边对应变量的值 var x, y int x, y = 1, 3 fmt.Println(x, y) x, y = y, x fmt.Println(x, y)&#125;// Fibonacci 数列func fib(n int) int &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; x, y = y, x+y &#125; return x&#125;func main() &#123; // test1() // test2() fmt.Println(gcd(16, 8)) fmt.Println(fib(3)) // fmt.Println(&quot;hello&quot;)&#125;","categories":[{"name":"go","slug":"go","permalink":"http://119.29.194.249/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://119.29.194.249/tags/go/"}]},{"title":"java方法CompareTo引发的错误","slug":"java方法CompareTo引发的错误","date":"2022-06-08T10:44:14.000Z","updated":"2022-11-14T02:32:59.817Z","comments":true,"path":"2022/06/08/java方法CompareTo引发的错误/","link":"","permalink":"http://119.29.194.249/2022/06/08/java%E6%96%B9%E6%B3%95CompareTo%E5%BC%95%E5%8F%91%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"","text":"java CompareTo方法 记录一下今天刷力扣的时候使用Arrays.sort时出现的错误 1Comparison method violates its general contract! 这个问题的意思就是说比较顺序需要满足可逆比较 我们看一下java实现的CompareTo方法 123456789101112131415161718public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125; 在这个compareTo方法中，从前到后比较第一个不同的字符，走到其中一个没有字符后，比较两者的长度 那么这个里面的一个东西时len1 - len2 当两个字符串相等的时候，需要返回0，特此注意一下","categories":[{"name":"开发","slug":"开发","permalink":"http://119.29.194.249/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"java","slug":"java","permalink":"http://119.29.194.249/tags/java/"},{"name":"bug修复","slug":"bug修复","permalink":"http://119.29.194.249/tags/bug%E4%BF%AE%E5%A4%8D/"}]},{"title":"线段树01","slug":"线段树01","date":"2022-06-06T14:56:22.000Z","updated":"2022-11-14T02:32:59.816Z","comments":true,"path":"2022/06/06/线段树01/","link":"","permalink":"http://119.29.194.249/2022/06/06/%E7%BA%BF%E6%AE%B5%E6%A0%9101/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class SegmentTree&#123; // 朴素版本的线段树 // 假设全部以区间和为例 static int[] a; static int[] f; public static void buildTree(int k,int l,int r)&#123; // 如果当前的区间，左端点等于右端点，那么这个区间的和为a[l]或a[r] if(l == r)&#123; f[k] = a[l]; return; &#125; int m = l + r &gt;&gt; 1; // left和right为当前区间的左孩子区间的索引和右孩子区间的索引 int left = 2 * k + 1; int right = 2 * k + 2; // 递归的创建左右子区间 buildTree(left, l, m); buildTree(right, m+1, r); // 当前区间的和为左孩子区间和右孩子区间的和 f[k] = f[left] + f[right]; &#125; // 讲a[x] 修改成y public static void update(int k, int l, int r, int x, int y)&#123; if(l == r)&#123; a[l] = y; f[k] = y; return; &#125;else&#123; int m = l + r &gt;&gt; 1, left = 2 * k + 1, right = 2 * k + 2; if(x&lt;=m)&#123; update(left, l, m, x, y); &#125;else&#123; update(right, m+1, r, x, y); &#125; f[k] = f[right] + f[left]; &#125; &#125; // 查询区间[s----t]之间的区间和 public static int query(int k, int l, int r, int s, int t)&#123; if(l == s &amp;&amp; r == t) return f[k]; else&#123; int m = l + r &gt;&gt; 1, left = 2 * k + 1, right = 2 * k + 2; if(s &gt; m)&#123; // 需要查询的区间和在当前区间的右边 return query(right, m+1, r, s, t); &#125;else&#123; if(t &lt;= m)&#123; // 需要查询的区间和在当前区间的左边 return query(left, l, m, s, t); &#125;else&#123; // 需要查询的区间在这两个区间的中间，左边有一部分，右边有一部分 return query(left, l, m, s, m) + query(right, m+1, r, m+1, t); &#125; &#125; &#125; &#125; public static void main(String[] args)&#123; // 静态测试一下 a = new int[]&#123; 2,4,1,5,7 &#125;; // f数组可以开大小，一般为4n f = new int[50]; buildTree(0, 0, 4); // 输出一下数据 for(int i = 0;i&lt;20;i++)&#123; System.out.print(f[i] + &quot; &quot;); &#125; System.out.println(); // 未修改之前为 13 &#123;1，5，7&#125; System.out.println(query(0, 0, 4, 2, 4)); update(0, 0, 4, 2, 3); for(int i = 0;i&lt;20;i++)&#123; System.out.print(f[i] + &quot; &quot;); &#125; System.out.println(); // 修改之后变成15 &#123;3，5，7&#125; System.out.println(query(0, 0, 4, 2, 4)); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://119.29.194.249/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"acwing基础算法之kmp","slug":"kmp","date":"2022-05-29T07:38:04.000Z","updated":"2022-11-14T02:32:59.812Z","comments":true,"path":"2022/05/29/kmp/","link":"","permalink":"http://119.29.194.249/2022/05/29/kmp/","excerpt":"","text":"题目描述 给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。 模板串 P 在模式串 S 中多次作为子串出现。 求出模板串 P 在模式串 S 中所有出现的位置的起始下标。 输入格式 第一行输入整数 N，表示字符串 P 的长度。 第二行输入字符串 P。 第三行输入整数 M，表示字符串 S 的长度。 第四行输入字符串 S。 输出格式 共一行，输出所有出现位置的起始下标（下标从 0 开始计数），整数之间用空格隔开。 样例 输入格式 12343aba5ababa 输出格式 10 2 解析 java代码 1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;class Main&#123; static int[] next; static int n,m; static String P,S; public static void getNext(char[] p)&#123; for(int i=2,j=0;i&lt;=n;i++)&#123; while(j!=0&amp;&amp;p[i]!=p[j+1]) j = next[j]; if(p[i]==p[j+1]) j++; next[i] = j; &#125; &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); P = sc.next(); m = sc.nextInt(); S = sc.next(); next = new int[P.length()+5]; P = &quot;1&quot;+P; S = &quot;1&quot;+S; char[] p = P.toCharArray(); char[] s = S.toCharArray(); getNext(p); StringBuilder sb = new StringBuilder(); for(int i=1,j=0;i&lt;=m;i++)&#123; while(j!=0&amp;&amp;s[i]!=p[j+1]) j = next[j]; if(s[i]==p[j+1]) j++; if(j==n)&#123; sb.append(i-j); sb.append(&quot; &quot;); j = next[j]; &#125; &#125; System.out.println(sb.toString()); &#125;&#125;","categories":[],"tags":[{"name":"kmp","slug":"kmp","permalink":"http://119.29.194.249/tags/kmp/"}]},{"title":"大数据之hash","slug":"大数据之hash","date":"2022-05-27T14:36:12.000Z","updated":"2022-11-14T02:32:59.812Z","comments":true,"path":"2022/05/27/大数据之hash/","link":"","permalink":"http://119.29.194.249/2022/05/27/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8Bhash/","excerpt":"","text":"jaccard相似度：用来描述两个集合间的相似度 jaccard(A，B) = (A^B)/(AUB)，即A与B交集的元素个数除以A与B并集的元素个数 K-single: 假如我们把一篇文章看成一个长的字符串，那么k-single就是这篇文章中长度为k的任意字符子串，一篇文章就是很多个不同的k-single的集合 例如 文章内容为&quot;abcdabd&quot;，k = 2 ,那么这篇文章中所有的k-single组成的集合为{ab,bc,cd,da,bd} 通过k-single的方式来表示每篇文章，然后通过判断每篇文章中single集合中相同元素的个数，可以得到文章的相似度 问题：以single的方式来存文章会消耗大量的内存 特征矩阵：特征矩阵的一列就对应一个集合，所有的行加起来就是所有集合元素的全集；如果集合中有这个元素，则矩阵中对应位置为1，否则为0 例子：假设现在有4个集合， 1S1=&#123;a,d&#125; S2=&#123;c&#125; S3=&#123;b,d,e&#125; S4=&#123;a,c,d&#125; 全集 1U =&#123;a,b,c,d,e&#125; 特征矩阵表示如下： S1 S2 S3 S4 a 1 0 0 1 b 0 0 1 0 c 0 1 0 1 d 1 0 1 1 e 0 0 1 0 mini Hash(最小hash) 为了计算最小hash,首先对特征矩阵的行进行打乱（即调整行与行之间的位置），这个打乱是随机的。 然后某一列的最小hash值就等于打乱后第一个值为1的行所在的行号，行号从0开始 最小hash与jaccard相似度，经过打乱后的两个集合计算得到的最小哈希值相等的概率等于这两个集合的jacccard相似度 最小哈希签名：当我们用多个随机打乱（假设为n个，分别为h1,h2,…,hn）来处理特征矩阵时，然后计算打乱后的这n个矩阵的最小哈希值，对于每个集合，都会有n个哈希值，这n个哈希值可以组成一个列向量[h1(S1),h2(S1),…,hn(Sn)]，如果有m个集合，就会有m个列向量，这m个列向量就会组成一个矩阵，这个矩阵就是特征矩阵的签名矩阵 最小签名的计算： 初始时，设置所有的sig(i,c)初始化为inf（无穷大） 先计算每一个hi® 对于每一行，如果某一列中的元素为1,讲sig(i,c)置为sig(i,c)和hi®之间的最小值，如果为0,则不进行操作 LSH 局部敏感性哈希算法： 如果有很多篇文章，那么如果要找出相似度很高的文档，我们两两比较，要比较的次数很多 讲矩阵分成很多个行条，每个行条会存在一个桶数组，如果再这个行条中集合a和集合b相似，将他们放在一个桶中，对于所有行条都不会存在一个桶中的集合，不在比较它们的相似度","categories":[{"name":"杂项内容学习","slug":"杂项内容学习","permalink":"http://119.29.194.249/categories/%E6%9D%82%E9%A1%B9%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://119.29.194.249/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Hash","slug":"Hash","permalink":"http://119.29.194.249/tags/Hash/"}]},{"title":"acwing基础算法-单调栈/单调队列","slug":"acwing基础算法-单调栈-单调队列","date":"2022-05-24T09:05:31.000Z","updated":"2022-11-14T02:32:59.811Z","comments":true,"path":"2022/05/24/acwing基础算法-单调栈-单调队列/","link":"","permalink":"http://119.29.194.249/2022/05/24/acwing%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"","text":"单调栈 用途：用于解决找到某一个数的左右端离他最近的比它小或者大的数 例子：给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。 1234567891011121314151617import java.util.*;class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] skt = new int[n+10]; int t = 0; for(int i=0;i&lt;n;i++)&#123; int x = sc.nextInt(); if(t!=0&amp;&amp;skt[t]&gt;=x) t--; if(t!=0) System.out.print(skt[t]+&quot; &quot;); else System.out.print(&quot;-1 &quot;); skt[++t] = x; &#125; &#125;&#125; 单调队列 用途: 用于解决找到一个滑动窗口中的最大值或者最小值 例子： 给定一个大小为 n≤106n≤106 的数组。有一个大小为 kk 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 kk 个数字。每次滑动窗口向右移动一个位置。你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值. 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 1000009;int q[N];int a[N];int h = -1, t = 0;int main()&#123; int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;n;i++)&#123; if(h&gt;=t&amp;&amp;i-k+1&gt;q[t]) t++; while(h&gt;=t&amp;&amp;a[q[h]]&gt;=a[i]) h--; q[++h] = i; if(i&gt;=k-1) printf(&quot;%d &quot;,a[q[t]]); &#125; printf(&quot;\\n&quot;); h = -1; t = 0; for(int i=0;i&lt;n;i++)&#123; if(h&gt;=t&amp;&amp;i-k+1&gt;q[t]) t++; while(h&gt;=t&amp;&amp;a[q[h]]&lt;=a[i]) h--; q[++h] = i; if(i&gt;=k-1) printf(&quot;%d &quot;,a[q[t]]); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"http://119.29.194.249/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"单调队列","slug":"单调队列","permalink":"http://119.29.194.249/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"acwing基础算法高精度加减乘除","slug":"acwing基础算法高精度加减乘除","date":"2022-05-13T10:54:09.000Z","updated":"2022-11-14T02:32:59.810Z","comments":true,"path":"2022/05/13/acwing基础算法高精度加减乘除/","link":"","permalink":"http://119.29.194.249/2022/05/13/acwing%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/","excerpt":"","text":"高精度加减乘除 高精度加法，两大大整数相加 1234567891011121314151617181920212223242526import java.util.Scanner;import java.lang.String;import java.lang.StringBuilder;public class Main&#123; public static String add(StringBuilder A,StringBuilder B)&#123; StringBuilder res = new StringBuilder(); for(int i=0,t=0;i&lt;A.length()||i&lt;B.length()||t!=0;i++)&#123; if(i&lt;A.length()) t += A.charAt(i) - &#x27;0&#x27;; if(i&lt;B.length()) t += B.charAt(i) - &#x27;0&#x27;; res.append(t%10); t /= 10; &#125; return res.reverse().toString(); &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); String a = sc.nextLine(), b = sc.nextLine(); StringBuilder A = new StringBuilder(a); StringBuilder B = new StringBuilder(b); A = A.reverse(); B = B.reverse(); String res = add(A,B); System.out.println(res); &#125;&#125; 高精度减法，两个大整数相减 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Scanner;import java.lang.String;import java.lang.StringBuilder;public class Main&#123; public static boolean ifBig(String a,String b)&#123; if(a.length()!=b.length()) return a.length()&gt;b.length(); for(int i=0;i&lt;a.length();i++)&#123; if(a.charAt(i)!=b.charAt(i)) return a.charAt(i)&gt;b.charAt(i); &#125; return true; &#125; public static String sub(StringBuilder A,StringBuilder B)&#123; StringBuilder res = new StringBuilder(); for(int i=0,t = 0;i&lt;A.length();i++)&#123; if(i&lt;B.length()) t -= B.charAt(i) - &#x27;0&#x27;; t += A.charAt(i) - &#x27;0&#x27;; res.append((t+10)%10); if(t&lt;0) t = -1; else t = 0; &#125; res = res.reverse(); //去除前导零 int l = 0; while(l&lt;res.length()-1)&#123; if(res.charAt(l)!=&#x27;0&#x27;) break; l++; &#125; return res.substring(l).toString(); &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); String a = sc.nextLine(), b = sc.nextLine(); StringBuilder A = new StringBuilder(a); StringBuilder B = new StringBuilder(b); A = A.reverse(); B = B.reverse(); if(ifBig(a,b))&#123; String res = sub(A,B); System.out.println(res); &#125; else&#123; System.out.print(&quot;-&quot;); String res = sub(B,A); System.out.println(res); &#125; &#125;&#125; 高精度乘法，一个大整数乘以一个小整数 12345678910111213141516171819202122232425262728293031import java.util.Scanner;import java.lang.String;import java.lang.StringBuilder;public class Main&#123; public static String mult(StringBuilder A,int b)&#123; StringBuilder res = new StringBuilder(); for(int i=0,t=0;i&lt;A.length()||t!=0;i++)&#123; if(i&lt;A.length()) t += (A.charAt(i)-&#x27;0&#x27;)*b; res.append(t%10); t /= 10; &#125; res = res.reverse(); // 处理前导零 int l = 0; while(l&lt;res.length()-1)&#123; if(res.charAt(l)!=&#x27;0&#x27;) break; l++; &#125; return res.substring(l).toString(); &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); String a = sc.nextLine(); int b = sc.nextInt(); StringBuilder A = new StringBuilder(a); A = A.reverse(); String res = mult(A,b); System.out.println(res); &#125;&#125; 高精度除法，大整数除以小整数 r为余数 123456789101112131415161718192021222324252627282930import java.util.Scanner;import java.lang.String;import java.lang.StringBuilder;public class Main&#123; static int r; public static String div(String a,int b)&#123; StringBuilder res = new StringBuilder(); for(int i=0;i&lt;a.length();i++)&#123; r = r*10 + a.charAt(i)-&#x27;0&#x27;; res.append(r/b); r %= b; &#125; // 处理前导零 int l = 0; while(l&lt;res.length()-1)&#123; if(res.charAt(l)!=&#x27;0&#x27;) break; l++; &#125; return res.substring(l).toString(); &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); String a = sc.nextLine(); int b = sc.nextInt(); String res = div(a,b); System.out.println(res); System.out.println(r); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"http://119.29.194.249/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"}]},{"title":"acwing01算法基础-二分","slug":"acwing01算法基础-二分","date":"2022-05-12T12:01:39.000Z","updated":"2022-11-14T02:32:59.809Z","comments":true,"path":"2022/05/12/acwing01算法基础-二分/","link":"","permalink":"http://119.29.194.249/2022/05/12/acwing01%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E4%BA%8C%E5%88%86/","excerpt":"","text":"今天，一起来二分吧！ 二分的思想: 二分的思想并不是为了解决在顺序列表中查找某个值，而是寻找边界情况 对于一个区间或者一些数据，有一些数据满足某个性质，剩下的数据不满足这个性质，二分可以找到他们这两部分之间的边界值。 整数二分 1.寻找左边界 12345678910void searchLeft(int l,int r,int[] nums)&#123; while(l&lt;r)&#123; // +1的原因在于一些死循环情况 int mid = l+r+1&gt;&gt;1; // check mid 表示判断mid这个点是否满足左区间的性质，满足返回true if(check(mid)) l = mid; else r = mid-1; &#125; // 注意，如果需要找的值在nums中，那么必然能找到，如果不在，跳出循环后l所表示的是最开始不满足左区间性质的那个值，对于查找顺序来说，l位置的值表示的是&gt;x(所要寻找的值)的第一个值&#125; 1234567void searchRight(int l,int r,int[] nums)&#123; while(l&lt;r)&#123; int mid = l+r&gt;&gt;1; if(check(mid)) r = mid; else l = mid + 1; &#125;&#125; 2.实战演练 acwing789 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;const int N = 1e6+9;int n;int arr[N];int qu[N];int q;bool check1(int mid,int k)&#123; if(arr[mid]&lt;=k) return true; else return false;&#125;bool check2(int mid,int k)&#123; if(arr[mid]&gt;=k) return true; else return false;&#125;// 当前找到的是右边界int search_Left(int k,int l,int r)&#123; while(l&lt;r)&#123; int mid = l+r+1&gt;&gt;1; if(check1(mid,k)) l = mid; else r = mid - 1; &#125; return l;&#125;// 当前找到的是左边界int search_Right(int k,int l,int r)&#123; while(l&lt;r)&#123; int mid = l+r&gt;&gt;1; if(check2(mid,k)) r = mid; else l = mid+1; &#125; return l;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;arr[i]); for(int i=0;i&lt;q;i++) scanf(&quot;%d&quot;,&amp;qu[i]); for(int i=0;i&lt;q;i++)&#123; int l = search_Left(qu[i],0,n-1); int r = search_Right(qu[i],0,n-1); if(arr[r]!=qu[i]) printf(&quot;-1 -1\\n&quot;); else printf(&quot;%d %d\\n&quot;,r,l); &#125; &#125; 12345678910111213141516171819202122232425262728293031import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(),q = sc.nextInt(); int[] p = new int[n]; for(int i=0;i&lt;n;i++) p[i] = sc.nextInt(); while(q--&gt;0)&#123; int x = sc.nextInt(); // System.out.println(x); int l = 0, r = n-1; while(l&lt;r)&#123; int mid = l+r&gt;&gt;1; if(p[mid]&gt;=x) r = mid; else l = mid+1; &#125; if(p[l]!=x) System.out.println(&quot;-1 -1&quot;); else&#123; System.out.print(l+&quot; &quot;); l = 0; r = n-1; while(l&lt;r)&#123; int mid = l+r+1 &gt;&gt;1; if(p[mid]&lt;=x) l = mid; else r = mid-1; &#125; System.out.println(r); &#125; &#125; &#125;&#125; 浮点二分 浮点二分的主要思路在于，分到最后小于某一个精度，就找到了答案 acwing790 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;int main()&#123; double n; scanf(&quot;%lf&quot;,&amp;n); // 判断是否大于0 double l,r; if(n&lt;0)&#123; if(n&gt;-1)&#123; l = -1; r = 0; &#125;else&#123; l = n; r = 0; &#125; &#125;else&#123; if(n&lt;1)&#123; l = 0; r = 1; &#125;else&#123; l = 0; r = n; &#125; &#125; while((r-l)&gt;1e-8)&#123; double mid = (l+r)/2; if(mid*mid*mid&gt;n) r = mid; else l = mid; &#125; printf(&quot;%lf&quot;,l);&#125; 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;import java.lang.String;public class Main&#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); double n = sc.nextDouble(); double l,r; if(n&lt;0)&#123; if(n&gt;-1)&#123; l = -1; r = 0; &#125;else&#123; l = n; r = 0; &#125; &#125;else&#123; if(n&lt;1)&#123; l = 0; r = 1; &#125;else&#123; l = 0; r = n; &#125; &#125; while((r-l)&gt;1e-9)&#123; double mid = (l+r)/2; if(mid*mid*mid&lt;n) l = mid; else r = mid; &#125; String result = String .format(&quot;%.6f&quot;,l); System.out.println( result); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://119.29.194.249/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"acwing算法基础课01-快排归并","slug":"acwing算法基础课01-快排归并","date":"2022-05-11T15:17:05.000Z","updated":"2022-11-14T02:32:59.808Z","comments":true,"path":"2022/05/11/acwing算法基础课01-快排归并/","link":"","permalink":"http://119.29.194.249/2022/05/11/acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE01-%E5%BF%AB%E6%8E%92%E5%BD%92%E5%B9%B6/","excerpt":"","text":"acwing 算法基础01 快排与归并排序 快排思想：分治 快排的处理步骤： 1.设定一个分界点m 2.调整区间，使得左边的部分小于等于这个分界点m，右边的部分大于等于这个分界点 3.递归调节左右两个区间 模板： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int N = 1e5+9;int n;int p[N];void quickSort(int l,int r)&#123; if(l&gt;=r) return; int c = p[(l+r)&gt;&gt;1]; // 为什么r与j不是l和r呢，因为使用了do while结构，需要先进行操作 int i=l-1,j=r+1; // 为什么使用do while结构，因为我们要注意p[i]=c的情况，do while结构会先操作，不会出现卡死再这里 while(i&lt;j)&#123; do&#123; i++; &#125;while(p[i]&lt;c); do&#123; j--; &#125;while(p[j]&gt;c); if(i&lt;j) swap(p[i],p[j]); &#125; // 注意边界问题，这里j结束循环，j所指向的是小于c的，所以j左边的必然小于c quickSort(l,j); quickSort(j+1,r);&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;p[i]); quickSort(0,n-1); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,p[i]);&#125; 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Main&#123; public static void quickSort(int l,int r,int[] p)&#123; if(l&gt;=r) return; int c = p[(l+r)&gt;&gt;1]; int i=l-1,j=r+1; while(i&lt;j)&#123; do&#123; i++; &#125;while(p[i]&lt;c); do&#123; j--; &#125;while(p[j]&gt;c); if(i&lt;j)&#123; int temp = p[i]; p[i] = p[j]; p[j] = temp; &#125; &#125; quickSort(l,j,p); quickSort(j+1,r,p); &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] p = new int[n]; for(int i=0;i&lt;n;i++) p[i] = sc.nextInt(); quickSort(0,n-1,p); for(int i=0;i&lt;n;i++) System.out.print(p[i]+&#x27; &#x27;); &#125;&#125; 归并排序思想:分治 归并排序步骤 1.找到中间位置，(l+r)&gt;&gt;1 2.对左边的部分进行排序，对右边的部分进行排序 3.将左右两个区间进行合并 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int N = 1e6+9;int n;int p[N];void mergeSort(int l,int r)&#123; if(l&gt;=r) return; int mid = l+r&gt;&gt;1; mergeSort(l,mid); mergeSort(mid+1,r); int temp[r-l+1]; int i=l,j=mid+1,k=0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; temp[k++] = p[i]&gt;p[j]?p[j++]:p[i++]; &#125; while(i&lt;=mid)&#123; temp[k++] = p[i++]; &#125; while(j&lt;=r)&#123; temp[k++] = p[j++]; &#125; i = l; k = 0; while(i&lt;=r)&#123; p[i++] = temp[k++]; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;p[i]); mergeSort(0,n-1); for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,p[i]);&#125; 123456789101112131415161718192021222324252627282930313233343536373839import java.util.Scanner;public class Main&#123; public static void mergeSort(int l,int r,int[] q)&#123; if(l&gt;=r) return; int mid = (l+r)&gt;&gt;1; mergeSort(l,mid,q); mergeSort(mid+1,r,q); // 进行归并排序 int[] temp = new int[r-l+1]; int i = l,j = mid+1;int k = 0; while(i&lt;=mid&amp;&amp;j&lt;=r)&#123; temp[k++] = q[i]&gt;q[j]?q[j++]:q[i++]; &#125; while(i&lt;=mid)&#123; temp[k++] = q[i++]; &#125; while(j&lt;=r)&#123; temp[k++] = q[j++]; &#125; i = l; k = 0; while(i&lt;=r)&#123; q[i++]=temp[k++]; &#125; &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] q = new int[n]; for(int i=0;i&lt;n;i++)&#123; q[i] = sc.nextInt(); &#125; mergeSort(0,n-1,q); for(int i=0;i&lt;n;i++)&#123; System.out.print(q[i]+&quot; &quot;); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"http://119.29.194.249/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"快排","slug":"快排","permalink":"http://119.29.194.249/tags/%E5%BF%AB%E6%8E%92/"},{"name":"归并","slug":"归并","permalink":"http://119.29.194.249/tags/%E5%BD%92%E5%B9%B6/"}]},{"title":"前缀树模板","slug":"前缀树模板","date":"2022-05-09T10:23:58.000Z","updated":"2022-11-14T02:32:59.808Z","comments":true,"path":"2022/05/09/前缀树模板/","link":"","permalink":"http://119.29.194.249/2022/05/09/%E5%89%8D%E7%BC%80%E6%A0%91%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"第一种表示方式，数组 1234567891011121314151617181920212223242526272829303132333435363738394041class Trie &#123; int N = 1000009; int[][] trie; int[] count; int index; public Trie() &#123; trie = new int[N][26]; count = new int[N]; index = 0; &#125; public void insert(String word) &#123; int p = 0; for(int i=0;i&lt;word.length();i++)&#123; int u = word.charAt(i)-&#x27;a&#x27;; if(trie[p][u]==0) trie[p][u] = ++index; p = trie[p][u]; &#125; count[p]++; &#125; public boolean search(String word) &#123; int p = 0; for(int i=0;i&lt;word.length();i++)&#123; int u = word.charAt(i)-&#x27;a&#x27;; if(trie[p][u]==0) return false; p = trie[p][u]; &#125; return count[p]!=0; &#125; public boolean startsWith(String prefix) &#123; int p = 0; for(int i=0;i&lt;prefix.length();i++)&#123; int u = prefix.charAt(i)-&#x27;a&#x27;; if(trie[p][u]==0) return false; p = trie[p][u]; &#125; return true; &#125;&#125; 第二种表示方式：链表 12345678910111213141516171819202122232425262728293031323334353637383940 class TreeNode&#123; boolean end; TreeNode[] tries = new TreeNode[26];&#125;class Trie &#123; TreeNode root; public Trie() &#123; root = new TreeNode(); &#125; public void insert(String word) &#123; TreeNode p = root; for(int i=0;i&lt;word.length();i++)&#123; int u = word.charAt(i)-&#x27;a&#x27;; if(p.tries[u]==null) p.tries[u] = new TreeNode(); p = p.tries[u]; &#125; p.end = true; &#125; public boolean search(String word) &#123; TreeNode p = root; for(int i=0;i&lt;word.length();i++)&#123; int u = word.charAt(i)-&#x27;a&#x27;; if(p.tries[u]==null) return false; p = p.tries[u]; &#125; return p.end; &#125; public boolean startsWith(String prefix) &#123; TreeNode p = root; for(int i=0;i&lt;prefix.length();i++)&#123; int u = prefix.charAt(i)-&#x27;a&#x27;; if(p.tries[u]==null) return false; p = p.tries[u]; &#125; return true; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"前缀树","slug":"前缀树","permalink":"http://119.29.194.249/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"}]},{"title":"并查集模板","slug":"并查集","date":"2022-05-05T00:54:00.000Z","updated":"2022-11-14T02:32:59.807Z","comments":true,"path":"2022/05/05/并查集/","link":"","permalink":"http://119.29.194.249/2022/05/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class UF&#123; private int[] parents; private int count; private int[] size; public UF(int n)&#123; parents = new int[n]; size = new int[n]; count = n; for(int i=0;i&lt;n;i++)&#123; parents[i] = i; size[i] = 1; &#125; &#125; public void union(int p,int q)&#123; int rootP = find(p); int rootQ = find(q); if(rootP==rootQ) return; // 否则将其中一个节点的根结点的父节点变成另一个节点的根节点 parents[rootP] = rootQ; size[rootQ] += size[rootP]; count--; &#125; public boolean connect(int p,int q)&#123; int rootP = find(p); int rootQ = find(q); return rootP==rootQ; &#125; public int find(int x)&#123; // 找到当前节点的根节点 while(parents[x]!=x)&#123; // 找到x的父节点，父节点找到自己的父节点，最后找到这棵树的头，把x接到这个头结点的地方 x = find(parents[x]); &#125; return parents[x]; &#125; public int getMaxSize()&#123; int res = 0; for(int i:size)&#123; res = Math.max(res,i); &#125; return res; &#125; public int getCount()&#123; return count; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://119.29.194.249/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"证明图的后序遍历的逆序是拓扑排序","slug":"证明图的后序遍历的逆序是拓扑排序","date":"2022-05-04T02:33:32.000Z","updated":"2022-11-14T02:32:59.803Z","comments":true,"path":"2022/05/04/证明图的后序遍历的逆序是拓扑排序/","link":"","permalink":"http://119.29.194.249/2022/05/04/%E8%AF%81%E6%98%8E%E5%9B%BE%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%80%86%E5%BA%8F%E6%98%AF%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"","text":"证明：对于图的后序遍历的逆序是拓扑排序？ 前提：我们需要保证，这个图是可以进行拓扑排序的 即这个图中不存在环，并且是有向图 1.什么是图的后序遍历 我们知道二叉树的后序遍历： 123456void traverse(TreeNode root)&#123; if(root==null) return; traverse(root.left); traverse(root.right); //后序遍历位置&#125; 同理，对于图的后序遍历可以这样表示 1234567void traverse(List&lt;Integer&gt;[] graph,int s)&#123; if(visit[s]) return; for(int v:graph[s])&#123; traverse(graph,v); &#125; //后序遍历位置&#125; 2.图的后序遍历特点 在上面，我们知道了后序遍历的大致实现方式，也就是对于一个节点，我们遍历完所有的它的相邻节点后，再进行相应的操作 以下图分析 显然上图是一个有向图，并且无环，满足题意 对于上图的后序遍历，它的遍历的顺序为3,2,4,1 3节点是最先遍历到的点，它的特点有什么呢？ 3节点没有出度，即到3节点的时候，它没有后序可遍历的节点了 3节点遍历完之后，由于没有后序节点遍历之后，那么会返回到上一级，那么它的上一级是谁? 有可能是1，也有可能是2，也有可能是4 如果是1，那么1还有后序节点未遍历，后序节点为2 如果是4，4也有后序节点未遍历，后序节点为2 如果是2，2没有后序节点了，所以2被遍历 以上步骤重复。。。。 我们注意到，当它被遍历，即被打印的时候，此时，它没有后序节点可以被遍历了，也就是说它没有出度了 3.为什么后序遍历的逆序是拓扑排序? 拓扑排序的步骤是，找到一个没有入度的节点，打印自己，然后删掉自身节点及相连的边，再重复操作 我们注意上面的后序遍历时节点被打印的时候，是自身没有出度了，那么它们之间是否顺序相反？ 答案是它们是相反的。 我们还通过上图进行证明：（反证法） 3、2、4、1是它的后序遍历结果，所以它的逆序为1、4、2、3 我们假设从2节点开始，遍历结果是错的 那么正确的应该是1、4、3、2 既然2、3是错的，必然3节点----&gt;2节点，如下图所示，否则，1、4、2、3也是正确的(对于拓扑排序来说) 显然这个图已经变了，也就是说3、2、4、1的后序遍历结果的逆序是正确的。 4.证明 那么推广一下，假设某图的后序遍历结果的逆序为（i,i+1,i+2,.....,j,j+1,j+2,....） 假设从j节点遍历结果是错的，那么必然存在一个节点k(k的后序遍历结果的位置在j后面)，k节点有边连接到j，k----&gt;j 所以假设错误，也就是说对于任意一个节点，这个假设都是错的，所以图的后序遍历的逆序是拓扑排序 证明结束","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图","slug":"图","permalink":"http://119.29.194.249/tags/%E5%9B%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://119.29.194.249/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"AcWing周赛47","slug":"AcWing周赛47","date":"2022-04-16T12:06:56.000Z","updated":"2022-11-14T02:32:59.787Z","comments":true,"path":"2022/04/16/AcWing周赛47/","link":"","permalink":"http://119.29.194.249/2022/04/16/AcWing%E5%91%A8%E8%B5%9B47/","excerpt":"","text":"1.数字母的题目4399 没什么坑，每个元素都是小写字母，比较简单的方法可以用个大小26的数组，然后有了就加1 最后查看有多少个不为0的 123456789101112131415161718import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String s = scanner.nextLine(); char[] arrs = s.toCharArray(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for(int i=0;i&lt;arrs.length;i++)&#123; if(arrs[i]&gt;=&#x27;a&#x27;&amp;&amp;arrs[i]&lt;=&#x27;z&#x27;)&#123; set.add(arrs[i]); &#125; &#125; System.out.println(set.size()); &#125;&#125; 2.链表使用题4400 主要是通过改变开始位置进行操作 我有点傻了，最开始还自定义了一个链表进行遍历删除 其实直接用数组就行了，因为n不大，主要是计算开始位置，每次除余的时候需要加上这个开始位置 12345678910111213141516171819202122232425262728293031import java.util.LinkedList;import java.util.List;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n=scanner.nextInt(),k=scanner.nextInt(); int[] arrs = new int[k]; for(int i=0;i&lt;k;i++)&#123; arrs[i] = scanner.nextInt(); &#125;// 使用LinkedList LinkedList&lt;Integer&gt; set = new LinkedList&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; set.add(i+1); &#125; int start = 0; for(int i=0;i&lt;k;i++)&#123; int length = arrs[i]; int size = set.size(); int lmod = (length+start)%size; System.out.print(set.get(lmod)); System.out.print(&quot; &quot;); set.remove(lmod);// 更新一下start start = lmod; &#125; &#125;&#125; 3.题目绕来绕去的一道数组题4401 主要是通过a数组先算一个长度为n的x数组，然后通过比较x数组开始k长的部分和结尾k长的部分 判断是否可以用更小长度的数组进行表示 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] arrs = new int[n]; for(int i=0;i&lt;n;i++)&#123; arrs[i]=scanner.nextInt(); &#125; int[] srrs = new int[n]; srrs[0] = arrs[0]; for(int i=1;i&lt;n;i++)&#123; srrs[i] = arrs[i]-arrs[i-1]; &#125;// 从后往前判断 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(n); for(int i=n-1;i&gt;0;i--)&#123; int l = n-i; boolean flag = true; for(int j=0;j&lt;l;j++)&#123; if(srrs[j]!=srrs[n-l+j])&#123; flag = false; break; &#125; &#125; if(flag) list.add(i); &#125; System.out.println(list.size()); for(int i=list.size()-1;i&gt;=0;i--)&#123; System.out.print(list.get(i)); System.out.print(&quot; &quot;); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"周赛","slug":"周赛","permalink":"http://119.29.194.249/tags/%E5%91%A8%E8%B5%9B/"}]},{"title":"删除链表的倒数第n个结点","slug":"删除链表的倒数第n个结点","date":"2022-04-16T08:51:33.000Z","updated":"2022-11-14T02:32:59.789Z","comments":true,"path":"2022/04/16/删除链表的倒数第n个结点/","link":"","permalink":"http://119.29.194.249/2022/04/16/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/","excerpt":"","text":"力扣19题 题目描述： 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 举例 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] java代码 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode h = new ListNode(); h.next = head; ListNode fastNode=head,slowNode=head,pre=h; for(int i=0;i&lt;n;i++)&#123; fastNode = fastNode.next; &#125; while(fastNode!=null)&#123; pre = slowNode; slowNode = slowNode.next; fastNode = fastNode.next; &#125; pre.next = slowNode.next; return h.next; &#125;&#125; 解释 通过设置两个指针，先让fastNode走n步，然后让slowNode开始走，这样fastNode走到最后的时候 slowNode正好到需要删除的地方","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://119.29.194.249/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"两两交换链表中的结点","slug":"两两交换链表中的结点","date":"2022-04-16T08:46:09.000Z","updated":"2022-11-14T02:32:59.787Z","comments":true,"path":"2022/04/16/两两交换链表中的结点/","link":"","permalink":"http://119.29.194.249/2022/04/16/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9/","excerpt":"","text":"力扣24题 题目描述： 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 举例 12输入：head = [1,2,3,4]输出：[2,1,4,3] java代码 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null||head.next==null) return head; // 先添加一个头节点 ListNode h = new ListNode(); h.next = head; ListNode pre=h; while(head!=null&amp;&amp;head.next!=null)&#123; ListNode temp = head.next.next; pre.next = head.next; head.next.next = head; head.next = temp; pre = head; head = pre.next; &#125; return h.next; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://119.29.194.249/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"反转链表","slug":"反转链表","date":"2022-04-16T08:42:22.000Z","updated":"2022-11-14T02:32:59.789Z","comments":true,"path":"2022/04/16/反转链表/","link":"","permalink":"http://119.29.194.249/2022/04/16/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"力扣206题 题目描述： 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 举例 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] java代码 递归写法 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; return reverse(null,head); &#125; public ListNode reverse(ListNode pre,ListNode cur)&#123; if(cur==null) return pre; ListNode temp = cur.next; cur.next = pre; return reverse(cur,temp); &#125;&#125; 非递归写法 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode pre,p; pre = head.next; p = head; p.next = null; while(pre!=null)&#123; ListNode temp = pre.next; pre.next = p; p = pre; pre = temp; &#125; return p; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://119.29.194.249/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"设计链表","slug":"设计链表","date":"2022-04-16T08:39:25.000Z","updated":"2022-11-14T02:32:59.803Z","comments":false,"path":"2022/04/16/设计链表/","link":"","permalink":"http://119.29.194.249/2022/04/16/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/","excerpt":"","text":"力扣707题 题目描述： 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： 1.get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 2.addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 3.addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 4.addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，5.则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 6.deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 举例 1234567MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3linkedList.get(1); //返回2linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3linkedList.get(1); //返回3 java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class ListNode&#123; int val; ListNode next; ListNode(int val)&#123; this.val = val; &#125; ListNode()&#123;&#125;&#125;class MyLinkedList &#123; ListNode head; public MyLinkedList() &#123; &#125; public int get(int index) &#123; ListNode p = head; int i = 0; while(p!=null)&#123; if(i==index) return p.val; i++; p = p.next; &#125; return -1; &#125; public void addAtHead(int val) &#123; if(head==null)&#123; head = new ListNode(val); &#125;else&#123; ListNode temp = new ListNode(val); temp.next = head; head = temp; &#125; &#125; public void addAtTail(int val) &#123; if(head==null) addAtHead(val); else&#123; ListNode p = head; while(p.next!=null)&#123; p = p.next; &#125; ListNode temp = new ListNode(val); p.next = temp; &#125; &#125; public void addAtIndex(int index, int val) &#123; if(index==0)&#123; addAtHead(val); return; &#125; ListNode p = head; ListNode pre = p; while(p!=null&amp;&amp;index&gt;0)&#123; pre = p; p = p.next; index--; &#125; if(index!=0) return; if(p==null&amp;&amp;index==0) addAtTail(val); if(p!=null)&#123; ListNode temp = new ListNode(val); pre.next = temp; temp.next = p; &#125; &#125; public void deleteAtIndex(int index) &#123; if(index==0) head = head.next; else&#123; ListNode p = head; ListNode pre = p; while(p!=null&amp;&amp;index&gt;0)&#123; pre = p; p = p.next; index--; &#125; if(p!=null)&#123; pre.next = pre.next.next; &#125; &#125; &#125;&#125;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */ 解释 展现链表基础知识和编程能力","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://119.29.194.249/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"每日一题479","slug":"每日一题479","date":"2022-04-16T08:28:49.000Z","updated":"2022-11-14T02:32:59.802Z","comments":true,"path":"2022/04/16/每日一题479/","link":"","permalink":"http://119.29.194.249/2022/04/16/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98479/","excerpt":"","text":"力扣479题 题目描述： 给定一个整数 n ，返回 可表示为两个 n 位整数乘积的 最大回文整数 。因为答案可能非常大，所以返回它对 1337 取余 。 举例 123输入：n = 2输出：987解释：99 x 91 = 9009, 9009 % 1337 = 987 这个题总共有8个测试样例，一个一个测试，然后打印出来就可以了。这题不好 而且这个题没有什么快速的做法，还是暴力枚举，只是用了一些小技巧，不让其超出时间限制 java代码 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int largestPalindrome(int n) &#123; if(n==1) return 9; int upper = (int)Math.pow(10,n)-1; for(int left = upper;left&gt;=0;left--)&#123; long p = left; for(int x=left;x&gt;0;x/=10)&#123; p = p*10 + x%10; &#125; if(isMult(n,p)) return (int)(p%1337); &#125; return 0; &#125;// // 判断是否是回文数// public boolean isPara(int a)&#123;// char[] cs = String.valueOf(a).toCharArray();// for(int i=0;i&lt;cs.length/2;i++)&#123;// if(cs[i]!=cs[cs.length-i-1]) return false;// &#125;// return true;// &#125;// 判断是否是两个数的相乘 public boolean isMult(int n,long target)&#123; int upper = (int)Math.pow(10,n)-1; for(long i=upper;i*i&gt;=target;i--)&#123; if(target%i==0) return true; &#125; return false; &#125;&#125; 解释 最开始的时候，我想着从2n-2位数往上判断时候是回文数，再判断是否可以被两个n位数相乘 这种情况会超出时间限制，答案的方式是从n位数往下是回文数的一边，生成另一边，然后判断， 这样会少判断很多数。这个题不太好，主要是测试样例少，使用一些小技巧避开了时间限制…","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://119.29.194.249/tags/%E6%A0%88/"}]},{"title":"每日一题385","slug":"每日一题385","date":"2022-04-16T03:47:49.000Z","updated":"2022-11-14T02:32:59.801Z","comments":true,"path":"2022/04/16/每日一题385/","link":"","permalink":"http://119.29.194.249/2022/04/16/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98385/","excerpt":"","text":"力扣385题 题目描述： 给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。 列表中的每个元素只可能是整数或整数嵌套列表 举例 12345678输入：s = &quot;[123,[456,[789]]]&quot;,输出：[123,[456,[789]]]解释：返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：1. 一个 integer 包含值 1232. 一个包含两个元素的嵌套列表： i. 一个 integer 包含值 456 ii. 一个包含一个元素的嵌套列表 a. 一个 integer 包含值 789 java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * // Constructor initializes an empty nested list. * public NestedInteger(); * * // Constructor initializes a single integer. * public NestedInteger(int value); * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // Set this NestedInteger to hold a single integer. * public void setInteger(int value); * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * public void add(NestedInteger ni); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return empty list if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */class Solution &#123;// 用来标识[ static final NestedInteger SIGN = new NestedInteger(0); public NestedInteger deserialize(String s) &#123; Deque&lt;NestedInteger&gt; deque = new ArrayDeque&lt;&gt;(); char[] c = s.toCharArray(); int n = c.length,i=0; while(i&lt;n)&#123; if(c[i]==&#x27;,&#x27;&amp;&amp;++i&gt;0) continue; else if(c[i]==&#x27;-&#x27;||(c[i]&gt;=&#x27;0&#x27;&amp;&amp;c[i]&lt;=&#x27;9&#x27;))&#123; int j = c[i]==&#x27;-&#x27;?i+1:i; int sum = 0; while(j&lt;n&amp;&amp;(c[j]&gt;=&#x27;0&#x27;&amp;&amp;c[j]&lt;=&#x27;9&#x27;))&#123; sum = sum*10 + (c[j++]-&#x27;0&#x27;); &#125; deque.addLast(new NestedInteger(c[i]==&#x27;-&#x27;?-sum:sum)); i=j; &#125;else if(c[i]==&#x27;[&#x27;)&#123; /* 在下一个else中。我们需要从栈中找到与其匹配的SIGN，找到之后对栈的最顶端的 NestedInteger进行添加，所以需要压栈一个NestedInteger */ deque.addLast(new NestedInteger()); deque.addLast(SIGN); i++; &#125;else&#123; /* 解释一下为什么要倒叙放入到NestedInteger中，因为list中的数据是栈中退出来的 所以它的顺序就是反过来的，为了添加的时候顺序正过来，需要倒叙添加 */ List&lt;NestedInteger&gt; list = new ArrayList&lt;&gt;(); while(!deque.isEmpty())&#123; NestedInteger poll = deque.pollLast(); if(poll==SIGN) break; list.add(poll); &#125; for(int j = list.size()-1;j&gt;=0;j--)&#123; deque.peekLast().add(list.get(j)); &#125; i++; &#125; &#125; return deque.peekLast(); &#125;&#125; 解释 栈的使用题，需要注意的是当需要出栈的时候，我们使用了一个List存在了里面，但是栈是后进先出的， 所以存放在list中的数据是倒叙的，故从list中取出来存到NestedInteger中的时候，需要反着来","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://119.29.194.249/tags/%E6%A0%88/"}]},{"title":"记录一下linux服务器的ip地址配置方法","slug":"记录一下linux服务器的ip地址配置方法","date":"2022-04-13T12:21:13.000Z","updated":"2022-11-14T02:32:59.786Z","comments":false,"path":"2022/04/13/记录一下linux服务器的ip地址配置方法/","link":"","permalink":"http://119.29.194.249/2022/04/13/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Blinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84ip%E5%9C%B0%E5%9D%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/","excerpt":"","text":"前言 在使用虚拟机时，初始化的时候电脑的网络配置是dhcp方式，这种方式每次重启电脑就会重新分配地址，ip地址是变化的 12345678910111213141516[root@localhost ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=17799946-980a-4924-8ab5-f2e27342386bDEVICE=ens33ONBOOT=yes BOOTPROTO=dhcp，这个每次电脑联网ip地址可能会发生变化 修改/etc/sysconfig/network-scripts/ifcfg-ens33 12345678910111213141516171819TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static #从dhcp改成staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=a342224e-81a8-4d8c-88a2-e11adeb9881cDEVICE=ens33ONBOOT=yesIPADDR=192.168.44.132 #静态ip地址NETMASK=225.225.225.0 #子网掩码GATEWAY=192.168.44.2 #网关DNS1=119.29.29.29 #DNS服务器,可以用各个大公司的","categories":[{"name":"Linux","slug":"Linux","permalink":"http://119.29.194.249/categories/Linux/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://119.29.194.249/tags/centos/"}]},{"title":"滑动窗口1","slug":"滑动窗口1","date":"2022-04-13T12:03:25.000Z","updated":"2022-11-14T02:32:59.786Z","comments":false,"path":"2022/04/13/滑动窗口1/","link":"","permalink":"http://119.29.194.249/2022/04/13/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A31/","excerpt":"","text":"力扣209题 题目描述： 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 举例 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 本题比较明显是使用滑动窗口的方法，但我在第一次提交的时候，虽然通过了，但是只击败了11%左右的用户，让我百思不得其解，后面发现，我写的滑动窗口复杂度还是O(n2)O(n^2)O(n​2​​),贴一下代码记录错误 1234567891011121314151617181920class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int windowsStart = 0; int windowsLength = 0; int minLength = Integer.MAX_VALUE; int sum = 0; while(windowsLength+windowsStart&lt;nums.length)&#123; sum += nums[windowsStart+windowsLength]; if(sum&lt;target)&#123; windowsLength++; &#125;else&#123; if(minLength&gt;windowsLength) minLength = windowsLength+1; windowsStart++; sum = 0; windowsLength = 0; &#125; &#125; return minLength==Integer.MAX_VALUE?0:minLength; &#125;&#125; 123456789101112131415161718class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int left = 0; int right = 0; int sum = 0; int minLength = Integer.MAX_VALUE; while(right&lt;nums.length)&#123; sum += nums[right]; while(sum&gt;=target)&#123; minLength = Math.min(minLength,right-left+1); sum -= nums[left]; left++; &#125; right++; &#125; return minLength==Integer.MAX_VALUE?0:minLength; &#125;&#125; 解释 left是滑动窗口的左边缘，right为滑动窗口的右边缘，由于我们找的是大于等于target的长度最短的 当left,left+1,…right的值大于left时，记录此时的滑动窗口的长度 为什么不用if，而使用while，我们在left向前走的一格中，可能left+1,left+2,…,right的值大于target","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://119.29.194.249/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"双指针3","slug":"双指针3","date":"2022-04-13T11:39:33.000Z","updated":"2022-11-14T02:32:59.785Z","comments":false,"path":"2022/04/13/双指针3/","link":"","permalink":"http://119.29.194.249/2022/04/13/%E5%8F%8C%E6%8C%87%E9%92%883/","excerpt":"","text":"力扣977题 题目描述： 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序排序 举例 1234输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] java代码 12345678910111213141516171819202122class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left = 0; int right = nums.length-1; int[] newNums = new int[nums.length]; int index = nums.length-1; int result1,result2; while(index&gt;=0)&#123; result1 = nums[left]*nums[left]; result2 = nums[right]*nums[right]; if(result1&gt;result2)&#123; newNums[index] = result1; left++; &#125;else&#123; newNums[index] = result2; right--; &#125; index--; &#125; return newNums; &#125;&#125; 解释 left和right分别指向数组的左右两端，如果left的平方大，left++,相反则right–，并将两者大的一方放到数组后面","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://119.29.194.249/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"双指针2","slug":"双指针2","date":"2022-04-13T07:40:24.000Z","updated":"2022-11-14T02:32:59.785Z","comments":false,"path":"2022/04/13/双指针2/","link":"","permalink":"http://119.29.194.249/2022/04/13/%E5%8F%8C%E6%8C%87%E9%92%882/","excerpt":"","text":"力扣26题 题目描述： 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 举例 12输入：nums = [1,1,2]输出：2, nums = [1,2,_] java代码 1234567891011121314151617class Solution &#123; public int removeDuplicates(int[] nums) &#123; int fastIndex=0,slowIndex=0; while(fastIndex&lt;nums.length)&#123; if(fastIndex==slowIndex)&#123; fastIndex++; &#125;else&#123; if(nums[fastIndex]==nums[slowIndex])&#123; fastIndex++; &#125;else&#123; nums[++slowIndex]=nums[fastIndex]; &#125; &#125; &#125; return slowIndex+1; &#125;&#125; 解释 双指针的变形题目 需要注意,fastIndex用来判断数组的nums[fastIndex]与slowIndex是否相等 当它们不相等的时候，nums[slowIndex+1]变成nums[fastIndex]","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://119.29.194.249/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"双指针1","slug":"双指针1","date":"2022-04-13T07:16:41.000Z","updated":"2022-11-14T02:32:59.785Z","comments":false,"path":"2022/04/13/双指针1/","link":"","permalink":"http://119.29.194.249/2022/04/13/%E5%8F%8C%E6%8C%87%E9%92%881/","excerpt":"","text":"力扣27题 题目描述： 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 举例 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案 java代码 1234567891011121314151617class Solution &#123; public int removeElement(int[] nums, int val) &#123; int fastIndex=0,slowIndex=0; while(fastIndex&lt;nums.length)&#123; if(nums[fastIndex]==val)&#123; fastIndex++; &#125;else&#123; if(fastIndex!=slowIndex)&#123; nums[slowIndex]=nums[fastIndex]; &#125; fastIndex++; slowIndex++; &#125; &#125; return slowIndex; &#125;&#125; 解释 在本题中，使用了两个指针，fastIndex和slowIndex 1.初始时，fastIndex与slowIndex都指向数组的头 2.每次扫描一个数组中的数据之后,fastIndex+1 3.当当前扫描的数据与目标数据相等时，slowIndex不变，否则slowIndex+1，进入下次循环 4.当当前扫描的数据与目标数据不相等时，判断fastIndex与slowIndex，两者相等，说明没有进行过第三步，即前面扫描过的数组数据没有出现目标数据，如果不相等，则将nums[slowIndex]=nums[fastIndex]，此时，fastIndex-slowIndex表示已经扫描过的数据中出现了这么多次目标数据，这样fastIndex扫描到数组结束后，slowIndex就是去掉目标数据后的数组长度","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://119.29.194.249/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"二分查找3","slug":"二分查找3","date":"2022-04-13T07:12:01.000Z","updated":"2022-11-14T02:32:59.784Z","comments":false,"path":"2022/04/13/二分查找3/","link":"","permalink":"http://119.29.194.249/2022/04/13/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE3/","excerpt":"","text":"力扣34题 题目描述： 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 请必须使用时间复杂度为 O(log n) 的算法。 举例 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 12输入：nums = [4], target = 4输出：[0,-0] java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int left = getLeft(nums,target); int right = getRight(nums,target); if(left==-1||right==-1)&#123; return new int[]&#123;-1,-1&#125;; &#125; if((right-left)&gt;=0)&#123; return new int[]&#123;left,right&#125;; &#125;else&#123; return new int[]&#123;-1,-1&#125;; &#125; &#125; int getLeft(int[] nums,int target)&#123; int left = 0; int right = nums.length-1; int leftIndex = -1; while(left&lt;=right)&#123; int middle = (left+right)/2; if(nums[middle]&gt;target)&#123; right = middle-1; &#125;else if(nums[middle]&lt;target)&#123; left = middle+1; &#125;else&#123; right = middle-1; leftIndex = middle; &#125; &#125; return leftIndex; &#125; int getRight(int[] nums,int target)&#123; int left = 0; int right = nums.length-1; int rightIndex = -1; while(left&lt;=right)&#123; int middle = (left+right)/2; if(nums[middle]&gt;target)&#123; right = middle-1; &#125;else if(nums[middle]&lt;target)&#123; left = middle+1; &#125;else&#123; left = middle+1; rightIndex = middle; &#125; &#125; return rightIndex; &#125;&#125; 解释 通过两个二分查找找到这个有序数组的目标值的左边界和右边界","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://119.29.194.249/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"不对称交通流交叉口信号控制优化模型","slug":"不对称交通流交叉口信号控制优化模型","date":"2022-04-13T06:35:10.000Z","updated":"2022-11-14T02:32:59.770Z","comments":true,"path":"2022/04/13/不对称交通流交叉口信号控制优化模型/","link":"","permalink":"http://119.29.194.249/2022/04/13/%E4%B8%8D%E5%AF%B9%E7%A7%B0%E4%BA%A4%E9%80%9A%E6%B5%81%E4%BA%A4%E5%8F%89%E5%8F%A3%E4%BF%A1%E5%8F%B7%E6%8E%A7%E5%88%B6%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"不对称交通流交叉口信号控制优化模型 解决问题：当预先当预先设置 的信号配时方案与道路地面交通组织不能够很好 地疏散交通流， 就会出现一方进口道排队长度较长， 路段发生堵塞； 另一方向车道放空， 绿灯利 用效率极低， 浪费道路 － 时间资源。 什么是不对称交通流？ 同一相位相对流向交通差异值较大 aciac_iac​i​​为第i相位的交通流不对称系数 qi1q_{i1}q​i1​​第i相位第1进道口单车道信号周期到达交通量 交通流不对称的状态以下几种 1.直行交通流对称，左转交通流不对称 判断左转车流是否到达设置左转保护相位的标准，直左或保护相位 2.左转交通流与直行交通流同侧不对称 设置进口道左转专用相位，当流量低的一侧车辆通行完毕后，该向左转停止放行。对向左转继续放行，并放行直行 3.左转交通流与直行交通流对侧不对称 同时放行直行与左转进口道，各相位的绿灯时间仅满足两进口道交通差值的一半 NEMA结构 NEMA规范中，每一个方向就代表一个相位，组合起来构成一个阶段。 当两个环相位到达屏障的相位时，必须同时切换道下一个相位 同时可以看到，1，5 1，6不会产生冲突 交叉口信号配时模型 传统信号相位 有效绿灯时间 本文根据NEMA相位结构优化的计算方式 实际的测试及分析 蚌埠市工农路与涂山路交叉口 存在的问题：左转交通流量较大 将交叉口进口道车辆转化称直行当量 计算是否需要设计左转保护相位 通过计算，东西进口在同时放行的时候，左转与直行会造成干扰，导致交通阻塞，设计相应的左转保护相位 以上展现出来的NEMA双环模型，然后计算各个相位的有效绿灯时间","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://119.29.194.249/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"智能交叉路口系统","slug":"智能交叉路口系统","permalink":"http://119.29.194.249/categories/%E6%99%BA%E8%83%BD%E4%BA%A4%E5%8F%89%E8%B7%AF%E5%8F%A3%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"NEMA","slug":"NEMA","permalink":"http://119.29.194.249/tags/NEMA/"}]},{"title":"ssh使用中的问题","slug":"ssh使用中的问题","date":"2022-04-13T04:38:43.000Z","updated":"2022-11-14T02:32:59.769Z","comments":true,"path":"2022/04/13/ssh使用中的问题/","link":"","permalink":"http://119.29.194.249/2022/04/13/ssh%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"什么是ssh ssh-安全外壳协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。也就是说，我们在进行远程登录时，避免信息泄露可以使用ssh协议。 ssh基础 ssh 提供两种级别的验证方法 1.基于口令的安全验证。即账号和密码 2.基于密钥的安全验证。本地创建一对密钥，并把公钥放在需要访问的服务器上。 查看服务器上是否启动了ssh 1234ps -ef |grep sshroot 1638 1 0 01:43 ? 00:00:00 /usr/sbin/sshd -Droot 4548 1638 0 12:46 ? 00:00:00 sshd: root@pts/0root 4609 4550 0 12:46 pts/0 00:00:00 grep --color=auto ssh windows端可以使用openssh 12 ssh -VOpenSSH_for_Windows_8.1p1, LibreSSL 3.0.2 从本地登录到服务器端 1234 ssh git@119.29.194.249Last login: Wed Apr 13 10:49:04 2022 from 183.222.235.102Last login: Wed Apr 13 10:49:04 2022 from 183.222.235.102[git@VM-8-7-centos ~]$ 由于我已经将公钥放到了服务器上，所以不需要进行密码验证 公钥的生成及上传 本地公钥生成 1ssh-keygen -t rsa 全部按enter键可以在本地/home/user名目录下生成.ssh文件夹，其中私钥文件id_rsa以及公钥文件id_rsa.pub (如果本地有就不需要再生成了)(windows /home是C:\\Users) 上传 1ssh-copy-id git@119.29.194.249 之后进行连接之后就不用登录了","categories":[{"name":"SSH","slug":"SSH","permalink":"http://119.29.194.249/categories/SSH/"},{"name":"Linux","slug":"Linux","permalink":"http://119.29.194.249/categories/Linux/"}],"tags":[{"name":"远程连接","slug":"远程连接","permalink":"http://119.29.194.249/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"}]},{"title":"二分查找2","slug":"二分查找2","date":"2022-04-12T12:18:44.000Z","updated":"2022-11-14T02:32:59.769Z","comments":false,"path":"2022/04/12/二分查找2/","link":"","permalink":"http://119.29.194.249/2022/04/12/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE2/","excerpt":"","text":"力扣35题 题目描述： 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 举例 12输入: nums = [1,3,5,6], target = 5输出: 2 java代码 1234567891011121314151617class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0; int right = nums.length-1; while(left&lt;=right)&#123; int middle = (left+right)/2; if(nums[middle]&gt;target)&#123; right = middle-1; &#125;else if(nums[middle]&lt;target)&#123; left = middle+1; &#125;else&#123; return middle; &#125; &#125; return left; &#125;&#125; 解释 本题目与二分查找第一题的不同在于，如果没找找到，上一题返回-1，本题返回该插入的位置 判断循环结束时的条件，此时left=right+1，而target&gt;nums[right]，故插入位置再left","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://119.29.194.249/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"二分查找1","slug":"二分查找1","date":"2022-04-12T12:08:11.000Z","updated":"2022-11-14T02:32:59.768Z","comments":false,"path":"2022/04/12/二分查找1/","link":"","permalink":"http://119.29.194.249/2022/04/12/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE1/","excerpt":"","text":"力扣704题 题目描述： 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 举例 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 java代码 1234567891011121314151617class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length-1; while(left&lt;=right)&#123; int middle = (left+right)/2; if(nums[middle]&lt;target)&#123; left = middle+1; &#125;else if(nums[middle]&gt;target)&#123; right = middle-1; &#125;else&#123; return middle; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二分查找","slug":"二分查找","permalink":"http://119.29.194.249/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]}],"categories":[{"name":"代理","slug":"代理","permalink":"http://119.29.194.249/categories/%E4%BB%A3%E7%90%86/"},{"name":"Redis","slug":"Redis","permalink":"http://119.29.194.249/categories/Redis/"},{"name":"go","slug":"go","permalink":"http://119.29.194.249/categories/go/"},{"name":"开发","slug":"开发","permalink":"http://119.29.194.249/categories/%E5%BC%80%E5%8F%91/"},{"name":"算法","slug":"算法","permalink":"http://119.29.194.249/categories/%E7%AE%97%E6%B3%95/"},{"name":"杂项内容学习","slug":"杂项内容学习","permalink":"http://119.29.194.249/categories/%E6%9D%82%E9%A1%B9%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/"},{"name":"Linux","slug":"Linux","permalink":"http://119.29.194.249/categories/Linux/"},{"name":"机器学习","slug":"机器学习","permalink":"http://119.29.194.249/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"智能交叉路口系统","slug":"智能交叉路口系统","permalink":"http://119.29.194.249/categories/%E6%99%BA%E8%83%BD%E4%BA%A4%E5%8F%89%E8%B7%AF%E5%8F%A3%E7%B3%BB%E7%BB%9F/"},{"name":"SSH","slug":"SSH","permalink":"http://119.29.194.249/categories/SSH/"}],"tags":[{"name":"clash","slug":"clash","permalink":"http://119.29.194.249/tags/clash/"},{"name":"redis","slug":"redis","permalink":"http://119.29.194.249/tags/redis/"},{"name":"go","slug":"go","permalink":"http://119.29.194.249/tags/go/"},{"name":"java","slug":"java","permalink":"http://119.29.194.249/tags/java/"},{"name":"bug修复","slug":"bug修复","permalink":"http://119.29.194.249/tags/bug%E4%BF%AE%E5%A4%8D/"},{"name":"线段树","slug":"线段树","permalink":"http://119.29.194.249/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"kmp","slug":"kmp","permalink":"http://119.29.194.249/tags/kmp/"},{"name":"大数据","slug":"大数据","permalink":"http://119.29.194.249/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Hash","slug":"Hash","permalink":"http://119.29.194.249/tags/Hash/"},{"name":"单调栈","slug":"单调栈","permalink":"http://119.29.194.249/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"单调队列","slug":"单调队列","permalink":"http://119.29.194.249/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"高精度","slug":"高精度","permalink":"http://119.29.194.249/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"二分","slug":"二分","permalink":"http://119.29.194.249/tags/%E4%BA%8C%E5%88%86/"},{"name":"基础算法","slug":"基础算法","permalink":"http://119.29.194.249/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"快排","slug":"快排","permalink":"http://119.29.194.249/tags/%E5%BF%AB%E6%8E%92/"},{"name":"归并","slug":"归并","permalink":"http://119.29.194.249/tags/%E5%BD%92%E5%B9%B6/"},{"name":"前缀树","slug":"前缀树","permalink":"http://119.29.194.249/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"name":"并查集","slug":"并查集","permalink":"http://119.29.194.249/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"图","slug":"图","permalink":"http://119.29.194.249/tags/%E5%9B%BE/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://119.29.194.249/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"周赛","slug":"周赛","permalink":"http://119.29.194.249/tags/%E5%91%A8%E8%B5%9B/"},{"name":"链表","slug":"链表","permalink":"http://119.29.194.249/tags/%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"栈","permalink":"http://119.29.194.249/tags/%E6%A0%88/"},{"name":"centos","slug":"centos","permalink":"http://119.29.194.249/tags/centos/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://119.29.194.249/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"双指针","slug":"双指针","permalink":"http://119.29.194.249/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"二分查找","slug":"二分查找","permalink":"http://119.29.194.249/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"NEMA","slug":"NEMA","permalink":"http://119.29.194.249/tags/NEMA/"},{"name":"远程连接","slug":"远程连接","permalink":"http://119.29.194.249/tags/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"}]}